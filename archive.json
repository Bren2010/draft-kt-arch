{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-01-02T00:17:15.917244+00:00",
  "repo": "Bren2010/draft-kt-arch",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pr-ready",
      "description": "",
      "color": "E90CE2"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOKhdr7c52lG3E",
      "title": "what happens (to users) if a keyserver goes bad?",
      "url": "https://github.com/Bren2010/draft-kt-arch/issues/1",
      "state": "OPEN",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We have a history of some key servers going bad. That could be due to attack, inability to operate or for other reasons. Regardless of the reason though, shouldn't the architecture describe e.g. a set of goals for how users and/or the overall system can recover from such a situation?",
      "createdAt": "2023-11-12T14:55:36Z",
      "updatedAt": "2023-12-06T21:07:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "(chair hat off)\r\n\r\nI am not sure if this section implies redundancy or not, but perhaps its enough to convince readers its in scope?\r\n\r\nhttps://bren2010.github.io/draft-kt-arch/draft-mcmillion-keytrans-architecture.html#name-third-party-auditing",
          "createdAt": "2023-12-06T21:02:29Z",
          "updatedAt": "2023-12-06T21:02:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Doesn't seem to address the issue as I read it. I think text about how a new log could potentially take over from an old one with the help of auditors of the old log or something like that might do the trick though. I guess that'd be a form of portability? Or maybe as you say, if common practice was for end users to not only use one log but to commonly make use of >1 independent logs, then maybe that'd be enough. I do think covering such issues in an architecture document would be needed or it'd never be covered later though.",
          "createdAt": "2023-12-06T21:07:43Z",
          "updatedAt": "2023-12-06T21:07:43Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOKhdr7c56DKuE",
      "title": "Definition of KT",
      "url": "https://github.com/Bren2010/draft-kt-arch/issues/2",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "The Introduction says, \"Any malicious entries added to such a log will generally be visible to all users, in which case a user can detect that they're being impersonated by viewing the public keys attached to their account.\" In the following paragraph, privacy is mentioned: \"KT can better preserve user privacy by only showing entries of the log to participants that genuinely need to see them.\" It is unclear what it means to say that all entries are generally visible to all users, while achieving privacy through access control. Maybe the sentence can be rephrased to: \"Any malicious entries added to such a log will be visible to the owners and recipients of the public-keys, in which case a user can detect that they're being impersonated by viewing the public keys attached to their account\".",
      "createdAt": "2023-12-18T23:40:00Z",
      "updatedAt": "2023-12-28T21:47:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOKhdr7c56DL5g",
      "title": "User Interactions",
      "url": "https://github.com/Bren2010/draft-kt-arch/issues/3",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "For Search: Would it make sense to add the following: \" if the corresponding version does not exist, server should return a proof of non-inclusion\"? I am also wondering if it is important to exclude batch update from the definition of Update (Note that this means that new values are added to the log immediately and are not queued for later insertion with a batch of other values.) since most scalable systems will do batching at least to some degree.",
      "createdAt": "2023-12-18T23:43:54Z",
      "updatedAt": "2023-12-28T21:51:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "I don't think that we can support proofs of non-inclusion, as they require leaking too much information about the number of entries in the database.\r\n\r\nI would support replacing language about \"batching\" with something that instead just captures the idea that there is no temporary SCT-style proof.",
          "createdAt": "2023-12-28T21:51:41Z",
          "updatedAt": "2023-12-28T21:51:41Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOKhdr7c56DNiY",
      "title": "Deployment Modes and Out-of-Band Communication",
      "url": "https://github.com/Bren2010/draft-kt-arch/issues/4",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "The relation between the Deployment Modes and Out-of-Band Communication is a bit unclear. Is Out-of-Band Communication assumed for all Deployment Modes? For example, the Contact Monitoring Mode says it is \"a single-party deployment with no third party\". But this would not be sufficient to detect forking attacks unless some Out-of-Band Communication or Bulletin Board is assumed.",
      "createdAt": "2023-12-18T23:49:10Z",
      "updatedAt": "2023-12-28T22:18:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "Out-of-Band Communication is available to detect forks in all deployment modes. Forking can still happen in the third-party modes if there's collusion",
          "createdAt": "2023-12-28T22:18:21Z",
          "updatedAt": "2023-12-28T22:18:21Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOKhdr7c56DQU5",
      "title": "Security Guarantees",
      "url": "https://github.com/Bren2010/draft-kt-arch/issues/5",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some additional parameters that would be nice to add in Section 6 (The parameters that determine the maximum amount of time before malicious behavior is detected are as follows:)\r\n\r\n1. What state is needed to be maintained by the client devices to detect malicious behavior\r\n2. What state the client devices need to maintain about the user's contacts to help detect malicious behavior\r\n3. Who detects the malicious behavior: the owner of the key, or its recipient\r\n\r\n\r\n\r\n",
      "createdAt": "2023-12-18T23:57:28Z",
      "updatedAt": "2023-12-19T01:04:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOKhdr7c56DSqg",
      "title": "Leakage to Third-Party",
      "url": "https://github.com/Bren2010/draft-kt-arch/issues/6",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "Section 6.1.1 says the following: \"In the case of a third-party auditor, the auditor is able to learn the total number of distinct keys in the log. It is also able to distinguish between real and fake modifications to the tree, and keep track of when individual keys are modified.\" Many of the KT systems so not suffer from this leakage: SEEMless, VeRSA, Verdict, Parakeet, ELEKTRA. Since this leakage in the third-party auditing mode is easily avoidable, I suggest removing the quoted part from Section 6.1.1.",
      "createdAt": "2023-12-19T00:04:00Z",
      "updatedAt": "2023-12-28T22:21:00Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": []
}