



Key Transparency                                            B. McMillion
Internet-Draft                                           18 October 2023
Intended status: Informational                                          
Expires: 20 April 2024


                     Key Transparency Architecture
              draft-mcmillion-keytrans-architecture-latest

Abstract

   This document defines the terminology and interaction patterns
   involved in the deployment of Key Transparency (KT) in a general
   secure group messaging infrastructure, and specifies the security
   properties that the protocol provides.  It also gives more general,
   non-prescriptive guidance on how to securely apply KT to a number of
   common applications.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://bren2010.github.io/draft-kt-arch/draft-mcmillion-keytrans-
   architecture.html.  Status information for this document may be found
   at https://datatracker.ietf.org/doc/draft-mcmillion-keytrans-
   architecture/.

   Discussion of this document takes place on the Key Transparency
   Working Group mailing list (mailto:keytrans@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/keytrans/.
   Subscribe at https://www.ietf.org/mailman/listinfo/keytrans/.

   Source for this draft and an issue tracker can be found at
   https://github.com/Bren2010/draft-kt-arch.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 20 April 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Protocol Overview
   4.  Client Operations
     4.1.  Out-of-Band Communication
   5.  Deployment Modes
     5.1.  Contact Monitoring
     5.2.  Third-party Management
     5.3.  Third-party Auditing
   6.  Security Guarantees
     6.1.  Privacy Guarantees
   7.  IANA Considerations
   8.  Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   Before any information can be exchanged in an end-to-end encrypted
   system, two things must happen.  First, participants in the system
   must provide the service operator with any public keys they wish to
   use to receive messages.  Second, the service operator must somehow
   distribute these public keys amongst the participants that wish to
   communicate with each other.

   Typically this is done by having users upload their public keys to a
   simple directory where other users can download them as necessary, or
   by providing public keys in-band with the communication being
   secured.  With this approach, the service operator needs to be
   trusted to provide the correct public keys, which means that the
   underlying encryption protocol can only protect users against passive
   eavesdropping on their messages.

   However most messaging systems are designed such that all messages
   exchanged between users flow through the service operator's servers,
   so it's extremely easy for an operator to launch an active attack.
   That is, the service operator can provide fake public keys which it
   knows the private keys for, associate those public keys with a user's
   account without the user's knowledge, and then use them to
   impersonate or eavesdrop on conversations with that user.

   Key Transparency (KT) solves this problem by requiring the service
   operator to store user public keys in a cryptographically-protected
   append-only log.  Any malicious entries added to such a log will
   generally be visible to all users, in which case a user can detect
   that they're being impersonated by viewing the public keys attached
   to their account.  However, if the service operator attempts to
   conceal some entries of the log from some users but not others, this
   creates a "forked view" which is permanent and easily detectable with
   out-of-band communication.

   The critical improvement of KT over related protocols like
   Certificate Transparency [RFC6962] is that KT includes an efficient
   protocol to search the log for entries related to a specific
   participant.  This means users don't need to download the entire log,
   which may be substantial, to find all entries that are relevant to
   them.  It also means that KT can better preserve user privacy by only
   showing entries of the log to participants that genuinely need to see
   them.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   *End-to-end Encrypted Communication Service:*  A communications
      service that allows end-users to engage in text, voice, video, or
      other forms of communication over the Internet, that uses public
      key cryptography to ensure that communications are only accessible
      to their intended recipients.

   *End-user Device:*  The device at the final point in a digital
      communication, which may either send or receive encrypted data in
      an end-to-end encrypted communication service.

   *End-user Identity:*  A unique and user-visible identity associated
      with an account (and therefore one or more end-user devices) in an
      end-to-end encrypted communication service.  In the case where an
      end-user explicitly requests to communicate with (or is informed
      they are communicating with) an end-user uniquely identified by
      the name "Alice", the end-user identity is the string "Alice".

   *Service Provider:*  The primary organization that provides the
      infrastructure and software resources necessary to operate an end-
      to-end encrypted communication service.

   *Transparency Log:*  A specialized service capable of securely
      attesting to the information (such as public keys) associated with
      a given end-user identity.  The transparency log is run either
      entirely or partially by the Service Provider.

3.  Protocol Overview

   From a networking perspective, KT follows a client-server
   architecture with a central _Transparency Log_, acting as a server,
   which holds the authoritative copy of all information and exposes
   endpoints that allow clients to query or modify stored data.  Clients
   coordinate with each other through the server by uploading their own
   public keys and/or downloading the public keys of other clients.
   Clients are expected to maintain relatively little state, limited
   only to what is required to interact with the log and ensure that it
   is behaving honestly.

   From an application perspective, KT works as a versioned key-value
   database.  Clients insert key-value pairs into the database where,
   for example, the key is their username and the value is their public
   key.  Clients can update a key by inserting a new version with new
   data.  They can also look up the most recent version of a key or any
   past version.  From this point forward, "key" will refer to a lookup
   key in a key-value database and "public key" or "private key" will be
   specified if otherwise.

   KT does not require the use of a specific transport protocol.  This
   is intended to allow applications to layer KT on top of whatever
   transport protocol their application already uses.  In particular,
   this allows applications to continue relying on their existing access
   control system.

   Applications may enforce arbitrary access control rules on top of KT
   such as requiring a user to be logged in to make KT requests, only
   allowing a user to lookup the keys of another user if they're
   "friends", or simply applying a rate limit.  Applications SHOULD
   prevent users from modifying keys that they don't own.  The exact
   mechanism for rejecting requests, and possibly explaining the reason
   for rejection, is left to the application.

4.  Client Operations

   TODO: Diagram showing a key update request over an application-
   provided transport layer getting accepted / rejected

   *  Explain monitoring: it proves that a previous lookup wasn't hidden
      from the database history, not that a key hasn't changed

4.1.  Out-of-Band Communication

   It is sometimes possible for a Transparency Log to present forked
   views of data to different users.  This means that, from an
   individual user's perspective, a log may appear to be operating
   correctly in the sense that all of a user's requests succeed and
   proofs verify correctly.  However, the Transparency Log has presented
   a view to the user that's not globally consistent with what it has
   shown other users.  As such, the log may be able to associate data
   with keys without the key owner's awareness.

   The protocol is designed such that users always remember the last
   TreeHead that they observed when querying the log, and require
   subsequent queries to prove consistency against this tree head.  As
   such, users always stay on a linearizable view of the log.  If a user
   is ever presented with a forked view, they hold on to this forked
   view forever and reject the output of any subsequent queries that are
   inconsistent with it.

   This provides ample opportunity for users to detect when a fork has
   been presented, but isn't in itself sufficient for detection.  To
   detect forks, users must either use *out-of-band communication* with
   other users or *anonymous communication* with the Transparency Log.

   With out-of-band communication, a user obtains a "distinguished"
   TreeHead that was issued closest to a given time, like the start of
   the day, by sending a Distinguished request to the Transparency Log.
   The user then sends the TreeHead along with the root hash that it
   verifies against to other users over some out-of-band communication
   channel (for example, an in-app screen with a QR code / scanner).
   The other users check that the TreeHead verifies successfully and
   matches their own view of the log.  If the TreeHead verifies
   successfully on its own but doesn't match a user's view of the log,
   this proves the existence of a fork.

   With anonymous communication, a user first obtains a "distinguished"
   TreeHead by sending a Distinguished request to the Transparency Log
   over their normal communication channel.  They then send the same
   Distinguished request, omitting any identifying information and
   leaving the last field empty, over an anonymous channel.  If the log
   responds with a different TreeHead over the anonymous channel, this
   proves the existence of a fork.

   In the event that a fork is successfully detected, the two signatures
   on the differing views of the log provide non-repudiable proof of log
   misbehavior which can be published.

5.  Deployment Modes

   In the interest of satisfying the widest range of use-cases possible,
   three different modes for deploying a Transparency Log are supported.
   Each mode has slightly different requirements and efficiency
   considerations for both the service operator and the end-user.

   *Third-party Management* and *Third-party Auditing* are two
   deployment modes that require the service operator to delegate part
   of the operation of the Transparency Log to a third party.  Users are
   able to run more efficiently as long as they can assume that the
   service operator and the third party won't collude to trick them into
   accepting malicious results.

   With both third-party modes, all requests from end-users are
   initially routed to the service operator and the service operator
   coordinates with the third party themself.  End-users never contact
   the third party directly, however they will need a signature public
   key from the third party to verify its assertions.

   With Third-party Management, the third party performs the majority of
   the work of actually storing and operating the log, and the service
   operator only needs to sign new entries as they're added.  With
   Third-party Auditing, the service operator performs the majority of
   the work of storing and operating the log, and obtains signatures
   from a lightweight third-party auditor at regular intervals asserting
   that the service operator has been constructing the tree correctly.

   *Contact Monitoring*, on the other hand, supports a single-party
   deployment with no third party.  The tradeoff is that executing the
   background monitoring protocol requires an amount of work that's
   proportional to the number of keys a user has looked up in the past.
   As such, it's less suited to use-cases where users look up a large
   number of ephemeral keys, but would work ideally in a use-case where
   users look up a small number of keys repeatedly (for example, the
   keys of regular contacts).

5.1.  Contact Monitoring

   TODO

5.2.  Third-party Management

   TODO

5.3.  Third-party Auditing

   TODO

6.  Security Guarantees

   A client that correctly verifies a proof from the Transparency Log
   (and does any required monitoring afterwards) receives a guarantee
   that the Transparency Log operator executed the key-value lookup
   correctly, and in a way that's globally consistent with what it has
   shown all other clients.  That is, when a client searches for a key,
   they're guaranteed that the result they receive represents the same
   result that any other client searching for the same key would've
   seen.  When a client modifies a key, they're guaranteed that other
   clients will see the modification the next time they search for the
   key.

   If the Transparency Log operator does not execute a key-value lookup
   correctly, then either:

   1.  The client will detect the error immediately and reject the
       proof, or

   2.  The client will permanently enter an invalid state.

   Depending on the exact reason that the client enters an invalid
   state, it will either be detected by background monitoring or the
   next time that out-of-band communication is available.  Importantly,
   this means that clients must stay online for some fixed amount of
   time after entering an invalid state for it to be successfully
   detected.

   The exact caveats of the above guarantee depend naturally on the
   security of underlying cryptographic primitives, but also the
   deployment mode that the Transparency Log relies on:

   *  Third-Party Management and Third-Party Auditing require an
      assumption that the service operator and the third-party manager/
      auditor do not collude to trick clients into accepting malicious
      results.

   *  Contact Monitoring requires an assumption that the client that
      owns a key and all clients that look up the key do the necessary
      monitoring afterwards.

6.1.  Privacy Guarantees

   For applications deploying KT, service operators expect to be able to
   control when sensitive information is revealed.  In particular, an
   operator can often only reveal that a user is a member of their
   service, and information about that user's account, to that user's
   friends or contacts.

   KT only allows users to learn whether or not a lookup key exists in
   the Transparency Log if the user obtains a valid search proof for
   that key.  Similarly, KT only allows users to learn about the
   contents of a log entry if the user obtains a valid search proof for
   the exact key and version stored at that log entry.

   Applications are primarily able to manage the privacy of their data
   in KT by enforcing access control policies on the basic operations
   performed by clients, as discussed in Section 3.  For example if two
   users aren't friends, an application can block these users from
   searching for each other's lookup keys.  This prevents the two users
   from learning about each other's existence.  If the users were
   previously friends but no longer are, the application can prevent the
   users from searching for each other's keys and learning the contents
   of any subsequent account updates.

   TODO specify the rest of the privacy guarantees of the finished
   protocol

7.  IANA Considerations

   This document has no IANA actions.

8.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC Editor, DOI 10.17487/rfc6962, June
              2013, <https://doi.org/10.17487/rfc6962>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Brendan McMillion
   Email: brendanmcmillion@gmail.com
